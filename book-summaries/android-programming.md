# Introduction to the Android Platform

1. The instructor is Adam Porter.
1. (...) This course is just one part of a multipart series, or specialization called mobile cloud computing with Android, or **MoCCA**, for short.

# The Android Development Environment

1. ???
1. Didn't watch the vid lol
1. Projects that were created with Eclipse can be *Imported* using "Import Project".

# Application Fundamentals - Part 1

1. Components of an app: **Activity, Service, BroadcastReceiver, ContentProvider**
    * `android.app.Activity`
    * `android.app.Service`
    * `android.content.BroadcastReceiver`
    * `android.content.ContentProvider`
1. Activities typically show a [single] thing the user can do. Activities on bigger screens may display more than one thing.
1. Services run in the background.
1. BroadcastReceivers subscribe to **Intents** that other applications publish.
    * You override `onReceive` in your subclass.
1. ContentProviders uh provide content.
    * ContentProviders can perform interprocess communication.
    * ContentProviders need not be implemented as databases.
    * ContentProviders encapsulate data sets.
    * Android supports several system-wide ContentProviders.
1. **Define resources** (non-code entities): manage your strings and layouts. **Plurals** are string arrays.
    * Define a string with `<string name="string_name">Foo</string>`
    * Resources can be changed without recompiling code.
    * Multiple groups of resources can be created for different device configurations.
    * Compiling an app with resources may be faster than if multiple copies of the same strings were hardcoded.
    * Strings are accessed in layouts with `@string/string_name`, or in code with `R.string.string_name`.
    * **`R`** is an autogenerated `R.java` file. It contains public members like `string` and `layout`.

# Application Fundamentals - Part 2

1. UI **Layouts** are defined in layout files. Use `@layout/layout_name` or `R.layout.layout_name` to access them.
1. Different screen orientations can reference different layouts (`layout`/`layout-land` might be an example-specific setting).
1. Activities should override the `onCreate` method.
1. You create an Activity with `onCreate`. The course quiz will say it is wrong. Skip it.
1. The `onCreate` method should restore saved state, set content view, initialise UI elements, and add events to the UI.
    * `super.onCreate(savedIntanceState)` might be required boilerplate code.
    * `setContentView(R.layout.main)` might also be boilerplate code. `setContentView` sets whichever look (layout) you want to look at.
1. You start an Activity with a `startActivity` method that comes out of nowhere.
1. Packaging information is in `AndroidManifest.xml`.
    * `<manifest>` is the root. Usually.
    * `<uses-sdk>` will be the node you mess up most often.
    * AndroidManifest.xml specifies the app icon and app name.

# The Activity Class - Part 1

1. Activities typically show a [single] thing the user can do. Activities on bigger screens may display more than one thing.
1. **Tasks** are a set of related Activities. These activities do not need to be semantically related.
1. Most Tasks start at the home screen.

## The Task Backstack

1. When an Activity is created, it goes onto the Backstack. Other Activities are suspended.
1. When an Activity is destroyed, it pops off the Backstack. The topmost Activity is then resumed.

## The Activity Lifecycle

1. Activities can be created or destroyed by code, the user (back button), or the system (memory pressure).
1. `onCreate`
    * Calls `super.onCreate()` (restores state)
    * Calls `setContentView()`
    * Gets/retains references to UI elements
    * Adds events to UI elements
1. `onStart`: Activity is "about to be visible"
    * Good for loading some persisted states, like downloading stuff.
1. **Resumed/Running**: visible, user interacting. `onStart`, `onResume`
    * `onResume` is called regardless of state after `onStart`.
    * `onResume` is called when the screen is turned back on when the Activity is in the foreground.
1. **Paused**: [might be] visible, user not interacting, can be terminated `onPause`
    * Can be used to stop foreground behaviours like a video
    * Can be used to persist state
1. **Stopped**: not visible, can be terminated `onStop`
    * In a perfect world, this is called only after an `onPause` was called. This is not the case if the app is killed.
    * Can be used to cache the state
    * Do not persist data here, persist in `onPause`
1. If the Activity is invisible, stopped, but the user goes back to that Activity, then [`onRestart`](https://stackoverflow.com/questions/35476452/when-do-onrestart-method-get-called-in-android) is called instead of `onResume`.
    * Processing of things after stopped
1. **Destroyed**: no longer in memory. Cannot be restarted. `onDestroy`
    * In a perfect world, this is called only after an `onStop` was called. This is not the case if the app is killed.
    * Use to free resources

# The Activity Class - Part 2

## Starting activities

1. `startActivity`: start an Activity. Expect nothing in return.
1. `startActivityForResult`: the Activity will half-assedly provide a result (`setResult()`). The result shows up in an `onActivityResult` in *your* class. This is called a *ShittyCallbackImpl*.
    * Results can have a code, `int resultCode` (`Activity.RESULT_CANCELED`, `Activity.RESULT_OK`, other custom codes).

## Handling configuration changes

1. When keyboard is popped up, orientation is changed, locale is changed, etc., your activity is ~~fucked~~destroyed and recreated. Make sure the two handlers are fast.
1. You can cache some data using the `onRetainNonConfigurationInstance` (deprecated) method, called in between `onStop` and `onDestroy`, and get that data back with `getLastNonConfigurationInstance()` (deprecated) in `onCreate`. The **Fragment** class now handles this.
1. `onConfigurationChanged` will be called when a configuration is manually changed. Specify the configurations you want to manually handle with [`android:configChanges`](https://developer.android.com/guide/topics/manifest/activity-element.html).
1. Avoid handling configuration changes manually. "It is more error-prone," said dude.

## The Intent Class - Part 1

1. Intents are more or less data structures.
1. **Explicit activation**: Intents name the Activity they want to start.
1. **Implicit activation**: Intents don't name the Activity they want to start. Intents name the operation they want to perform; the system then selects the Activity to perform that operation.
1. Intents provide a way to want some work to be done, like "take a photo" or "pick a contact".
1. Intents can also be used to imply that an event has occurred, to represent the event (something like "user clicked share", but not using BroadcastReceivers for some reason).

### Intent fields

1. **Action**: a string that names the operation to be performed. `Intent.ACTION_DIAL` means you want to call a number. `ACTION_EDIT` means you want to edit something. `ACTION_SYNC` means you want to sync. `ACTION_MAIN` means you want to start an Activity as a main Activity of an app.
    * The `intent-filter` tags for the **main Activity** are `<action android:name="android.intent.action.MAIN" />` and `<category android:name="android.intent.category.LAUNCHER" />` (if it should also show up in the launcher?).
    * You can either initialise an Intent with the Action, or `.setAction(THE_ACTION)`.
    * `ACTION_PICK` gives you back the URI of the resource (like a contact).
1. **Data**: a URI.
    * Example: `geo:`/`tel:` URIs.
    * You may need to use `Uri.parse()` on these strings first.
    * You can `.setData(THE_DATA)`.
1. **Category**: additional information about the components that can or should handle this Intent.
    * `CATEGORY_BROWSABLE`: can be invoked by a browser.
    * `CATEGORY_LAUNCHER`: can be the initial activity of a task... is listed in the top-level app launcher. (???)
1. **Type**: the MIME type of the Intent Data.
    * Example: `image/png`
    * Set with `.setType(THE_TYPE)` or `.setDataAndType(THE_DATA, THE_TYPE)`.
    * If left unspecified, Android may guess it for you.
1. **Component**: identifies the Intent's target Activity (if you know there is one and only one).
    * This is a `Class`.
    * Set the target Activity with `.setComponent()`, `.setClass()`, or `.setClassName()`.
1. **Extras**: extra information as K-V pairs.
    * The target Activity will have to know how to use it.
    * Set each extra with `.putExtra(EXTRA_NAME, EXTRA_DATA)`.  (overloaded for various types)
1. **Flags**: information about how the Intent should be handled.
    * `FLAG_ACTIVITY_NO_HISTORY`: Once started, the Activity should not be put in the history stack.
    * `FLAG_DEBUG_LOG_RESOLUTION`: Prints extra log information.

## The Intent Class - Part 2

1. Explicit Activation starts an Activity using an Intent with a specific Component. You may construct an Intent with `new Intent(context, class)`. Example: `new Intent(CurrentClass.this, TargetIntent.class)`.
1. Implicit Activation relies on **Intent Resolution** based on the desired operation and **Intent Filters**, the operations that an Activity can handle.
    * IntentFilters are (usually) stored in `AndroidManifest.xml`, in the form of `<activity ..> <intent-filter ..> <action ..><action ..><action ..>`.
    * Each `data` specifies (if desired) the `android:mimeType`, `android:scheme`, `android:host`, `android:post`, ... for each `<intent-filter>`.
    * An IntentFilter that handles maps would have `<data android:scheme="geo" />`.
    * IntentFilters can also have `<action>` and `<category>` children.
    * In order to receive Implicit Intents, an Activity must specify an IntentFilter with the Category `android.intent.category.DEFAULT`.
    * Intent Resolution uses only `data`, `action` and `category` fields. `flags` and `extras` are not used.
1. Intent **Priority**: `android:priority` (from -1000, lowest, to 1000, highest) can be used to specify how high of a priority your Activity should appear to the user by default. The user may override that by choosing something else.
1. `adb dumpsys (package name)` shows all IntentFilters in a package (among other things).

## Permissions

1. Android uses Permissions to protect resources (like the camera) and data (like contacts). Some costly operations like sending SMS are also protected.
1. Permissions are declared in the form of `<uses-permission>` strings. Example: `<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION">`
1. `uses-permission` tags can be custom strings.

### Limiting Permissions

1. If your Application does something risky, it is possible to require other Applications/Activities to have sets of permissions in order to launch your Application.
1. Define permissions required to launch your app with the `<manifest ...> <permission ...>` tag. Example: `<permission android:name="foo.PERMISSION_BAR">`.
1. Give your own app the permission to launch itself by having `android:permission="foo.PERMISSION_BAR"` in its `<application ...` tag.
1. Apps started without the required permission (for example, started by some app without that permission) will get an error.

### Component permissions **take precedence over application permissions**

Throws `SecurityException`.

1. **Activity Permissions** restrict which components can start an Activity.
    * Enforced at `startActivity` and `startActivityForResult`.
1. **Service Permissions** restrict which components can start or *bind to* a service.
    * Enforced at `Context.startService`, `Context.stopService`, and `Context.bindService`.
1. **BroadcastReceiver Permissions**
1. **ContentProvider Permissions**

## The Fragment Class - Part 1

* **Fragments** are portions of an Activity.
1. Tablet UIs are more complicated than phone UIs. Fragments can help make a more complicated interface in a single Activity (?).
1. A single Fragment can be reused across multiple Activities.
    * [`Fragment` is not a subclass of `Activity`.](https://developer.android.com/reference/android/app/Fragment.html)
1. Fragments are hosted by Activities. Therefore, Fragment lifecycles are tied to their parent Activities (with a few extras).
    * **Resumed**: Fragment is visible in the running Activity.
    * **Paused**: Fragment is visible, but some other Activity has focus.
    * **Stopped**: Fragment is invisible.
1. When an Activity is about to be created, its Fragments will get special calls in this sequence:
    * `onAttach`: Fragment is attached to the Activity.
    * `onCreate`: Fragment (not the Activity) is created. You don't set up the interface with this. You do so in `onCreateView`.
    * `onCreateView`: Sets up and returns a view containing the user interface. This UI can be installed into the hosting Activity. After this method, the Activity's `onCreate` will be called.
    * `onActivityCreated`: the Activity's `onCreate` was called.
1. When an Activity has its `onStart`, `onResume`, `onStop` called, the Fragment's respective methods will also be called.
1. When an Activity is destroyed, its Fragments will get special calls in this sequence:
    * `onDestroyView`: The opposite of `onCreateView`.
    * `onDestroy`: The Fragment is no longer in use. You can clean up its resources here.
    * `onDetach`: You null out references to the host Activity here.

## The Fragment Class - Part 2

1. Fragments can be added to Activities:
    * Statically: adding one into the layout.
    * Programmatically: adding one using the **`FragmentManager`**. **Layouts** can be inflated/implemented in `onCreateView`.
    * **Inflating** means turning a Layout XML into a Java object.
    * Fragments' `onCreateView` methods give an `LayoutInflater inflater`. You use the `inflater` to inflate your Fragment XML, attach it to another argument `ViewGroup container`, and then have `onCreateView` return it.
1. Layouts (like `LinearLayout`) will host your Fragments.

### Adding Fragments programmatically

1. Get a reference to `FragmentManager`.
    * `FragmentManager fragmentManager = getFragmentManager();  // oh boy are you going to love the syntax`
1. Begin a `FragmentTransaction`.
    * `FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();  // my pinky is starting to hurt`
1. Add the Fragment [to the Activity].
    * `fragmentTransaction.add(R.id.foo_frame, new SomeFragment();`
    * You define sub-Layouts with these `R.id`s. Example: `FrameLayout`.
1. Commit the `FragmentTransaction`.
    * `fragmentTransaction.commit();`

### Dynamic Layout

1. Lets you decide what to do with screen space in run-time (like checking if it is a phone or a tablet).
1. Also lets you change layout based on events, like a click. Again, you will be using the `FragmentManager`.
    * `fragmentTransaction.addToBackStack(null)` will bring you back to the original layout if the user presses back.
1. `fragmentManager.executePendingTransactions()` will layout immediately. Apparently this is not the default.

### Configuration changes

1. `onRetainNonConfigurationInstance` and `getLastNonConfigurationInstance` are deprecated, replaced by methods in the Fragment class.
1. If you call `setRetainInstance(true)` on the Fragment (usually in the Fragment's `onCreate`), then when configuration changes occur, Android will kill the activity, but not destroy its fragments. Instead, it will save that fragment state and it will detach the fragment from the activity.
    * `onDestroy` will not be called on the Fragment (because it is not destroyed).
    * `onCreate` will not be called on the Fragment (not created because it was not destroyed).
1. On configuration change, you still handle your own restore code.